GIF Анимации
============
Прежде чем начать редактировать Flash-проекты, находящиеся в поддиректориях, рекомендую прочесть следующий раздел.
Он может сберечь ваши нервные клетки.

**Note**: на самом деле это **не** _ReadMe_, это и **не** _статья_, и **не** _How-to_, это один большой **NOTE**.

Это будет не просто...
----------------------
Если вы нечасто работаете во Flash Professional, и в основном делали ~~простые~~ анимации, в которых не была важна точность (на которых редко заметишь нюансы инструмента), то вам следует знать, что может ~~_взбесить_~~ _расстроить_:

- Объекты внутри группы могут сдвигаться друг относительно друга при применении трансформации (`fl.getDocumentDOM().transformSelection()`) к группе.

  **Пример**:
    1. нарисуйте небольшой прямоугольник (в режиме создания объекта)
    1. в центре прямоугольника разместите любую надпись (статический текстовый блок)
    1. сгруппируйте их
    1. и через панель/палитру "Transform" пропорционально масштабируйте группу:
       1. включить режим сохранения пропорции - "цепочка";
       1. и непрерывно менять масштаб при помощи мышки:
          1. навести мышку на значение масштаба,
          1. нажать,
          1. и двигать влево-вправо (при этом смотрите, как текстовый блок начнет смещаться относительно прямоугольника).

  **Решение**:  
    Масштабировать при помощи инструмента "Free Transform" с зажатым <kbd>Shift</kbd> (для сохранения пропорций), при этом будет использоваться `fl.getDocumentDOM().scaleSelection()`.

  **Примечание**:  
    **Если** воспользоваться панелью/палитрой "Properties", которая также использует `fl.getDocumentDOM().scaleSelection()`, то текстовый блок по-прежнему будет смещаться. При этом можно наблюдать за тем, как "ползет" _transform-point_ - просто меняйте значения масштаба при активном инструменте "Free Transform".

    **Если** убрать группу, и просто выделить ранее сгруппированные объекты, а затем их масштабировать, то все\* будет в порядке.  
    __*__ - _см. следующий пункт_

- Объекты, после разгруппировки, перестали смещаться друг относительно друга, но продолжили "ползти" относительно холста.

  **Пример**:
    1. создайте один объект (_прямоугольник_)
    1. меняйте его ширину или высоту в панели/палитре "Properties" (_или в "Info"_)
    1. и смотрите на координаты левого верхнего угла в "Info" (_координаты обновляются только после завершения масштабирования_).

  **Решение**:  
    Опять же используем "Free Transform", но теперь с зажатым <kbd>Alt</kbd>, чтобы масштабирование было не относительно _transform-point_, а относительно противоположной стороны/угла.

- Новая анимация (tween) - _не точная_ - если сдвинуть положение объекта в конце анимации, то сдвинется и координаты в начале анимации.

  **Примечание**:  
    Сдвинутся немного, но этого хватит, чтобы объект стал размытым.  
    В обратном направлении тоже "работает" - если двигать начало, то сместится конец.

  **Демонстрация**:
    1. создать движения с двумя ключевыми кадрами, привязанными ко времени - в начале и конце
    1. затем двигать объект на холсте

- Практически для всего приходится создавать свой символ (чтобы анимировать: перемещение, масштабирование, изменение прозрачности, ...), и при изменении содержимого - создавать еще один символ...

- В свете описанного в предыдущем пункте - не хватает возможности настроить папку по умолчанию для новых символов <kbd>F8</kbd>, чтобы:
  - новые символы с названием по умолчанию `Symb #` не смешивались (в меню выбора символов) с символами, которым было дано название (на данный момент символы `Symb #` оказываются в начале списка, а именованные символы - в конце, и если символов много, то приходится прокручивать список при открытии именованного символа, а их я открываю чаще, чем не именованные)
  - продолжала работать автоматическая генерация уникального имени (`Symb #`) для новых символов.

  Я бы назвал папку для новых символов "heap" (кучей).

  **Обходные пути**:
    - Отредактировать файл с локализацией `fl_dictionary.dat` (он находится в `<директория установки Animate/Flash>/<язык локализации>/<язык локализации>/fl_dictionary.dat`) - нужно найти `IDS_DOC_SYMBOL` и `IDS_DOC_SYMBOL_S55` и заменить всю строку на `"$$$/IDS_DOC_SYMBOL=|heap %i"` и `"$$$/IDS_DOC_SYMBOL_S55=|heap @0"` соответственно.  
    Все новые символы будут иметь формат имени `|heap #`, и будут расположены в конце списка (ниже них будут только символы, начинающиеся с `~`).
    - Создать папку `_` и размещать все именованные символы в ней. Эта папка всегда будет в начале списка.

- Трудно перемещать уже анимированные объекты (несколько ключевых кадров на нескольких слоях) из основной тайм-линии в символ и обратно. Нужно _копировать кадры_, и вставлять в символе, но при этом объекты сохранят свои абсолютные координаты (из основной тайм-линии), и мне приходится менять на новые координаты - относительно точки вставки символа на холст в основной тайм-линии:
  1. включить режим редактирования нескольких кадров,
  1. выделить все объекты в символе,
  1. и поменять координаты.

  Но есть проблемы с _анимацией формы_ и _хинтами_ (_см. следующий пункт_).

- Иногда удается обойтись без создания нового символа, и воспользоваться _анимацией формы_, но если при этом понадобится добавить _хинты_ (точки-подсказки для морфинга), то возникнут проблемы, если в будущем понадобится переместить объект в другое место. _Хинты_ не перемещаются вместе с объектом, их даже нельзя выделить скопом и переместить на новое место - только по одному.

- Маленькие (менее 3.4 пикселя по любой из сторон) объекты морфировать не удастся - будет пустота вместо промежуточных кадров.  
_Хинты_ также могут поломать морфинг, особенно при увеличении их количества (на небольшом объекте, где нужны были 12 хинтов, получилось добавить только 6).

- Я в большинстве случаев не смог использовать функцию "копировать движение" в тайм-линии - если в анимации есть поворот, то объект сдвигается относительно своего _transform-point_ (точки трансформации).

  **Примечание** / **Демонстрация**:  
    - я размещал transform-point в одном из 4-х углов, и было видно, что объект сдвинулся;
    - смотрел на максимальном увеличении - 2000%.

  **Приходилось**:
    - либо копировать кадры, и двигать их (режим _редактирования нескольких кадров_),
    - либо для объекта (символа) с другими размерами - воссоздавать все движение заново (помогал _экспорт в XML_ параметров существующей анимации).

- Это удивительно, но у меня не получилось в тайм-линии:
  1. выделить ключевые кадры с зажатым <kbd>Ctrl</kbd>/<kbd>cmd</kbd> на разных (не рядом расположенных) слоях,
  1. сдвинуть их влево/вправо, захватившись за одно из выделений.

  При этом просто создается новое выделение.

  Для рядом расположенных слоев, и выделением при помощи <kbd>Shift</kbd> - все работает, однако он любит создавать новые ключевые кадры на границе выделения, которые затем приходится удалять.

- Когда на тайм-линии внутри символа анимируются несколько действий, то при работе в родительской тайм-линии хочется видеть начало и конец действий.

  В After Effects для этого можно ставить маркеры на тайм-линии "символа", и их будет видно при использовании этого "символа".  
  В Animate/Flash маркеры можно "ставить" только на ключевые кадры, и эти маркеры не видны при использовании символа в родительской тайм-линии.

  Не хватает опции для маркера "отображать маркер в родительской тайм-линии" - тогда можно будет выборочно делать видимыми некоторые из маркеров.

- Если
  - уже создано много _слоев_,
  - _слои_ сгруппированы в _папки_,
  - и надо применить _маску_ ко всем _слоям_ в этих _папках_,

  то не получится просто поместить внутрь _маски_, сгруппированные в _папки_ _слои_. Придется переносить все папки (вместе со слоями) в новый символ...

  Что в будущем приведет к некоторым трудностям при редактировании:
    находясь внутри вложенного символа "in-place edit", перемещение по времени не будет обновлять изображение родительского символа.

- Если
  - создать маску - кольцо (т.е. круг с _внутренним вырезом_ - "внутренний радиус" != 0),
  - и использовать "анимацию формы" для изменения радиуса внутренней окружности во времени,

  то _внутренний вырез_ во время анимации будет просто исчезать.

  **Решение**:  
    Изменить топологию - разрезать кольцо, задав минимальный "начальный угол" для образования разреза.

- Два во многом дублирующих типа символа (библиотека): "Графика" и "Клип".  
  Но _9-и секционное масштабирование_ и _режимы смешивания цветов_ доступны только для "Клип".

  Основное предназначение "Клип" - не быть привязанным к родительской тайм-линии  
  ➔ при экспорте в GIF, "Клип" (вместе с _9-и секционным масштабированием_ и _режимами смешивания цветов_) получится использовать только для статичных символов, т.к. "Клип" не будет проигрываться (будет отображаться только первый кадр).

- Было бы здорово иметь расширенную функцию _9-и секционного масштабирования_ - с произвольным количеством столбцов и строк.

  Каждому столбцу/строке можно задать поведение при масштабировании:
  - размер столбца/строки меняется при масштабировании
  - размер столбца/строки фиксирован - сохраняет свое значение при масштабировании

  В еще **более расширенной** версии функции можно задавать процентное соотношение растягивающихся (резиновых) столбцов/строк при масштабировании. Чтобы резиновые столбцы/строки можно было масштабировать не пропорционально их начальному размеру.

  **Пример** (для _более расширенной_ версии):  
  Разметка:
    - 2 резиновых столбца (в 100% масштабе каждый столбец занимает 50% от исходного размера объекта)
    - 1 фиксированная строка

  После масштабирования до 200%: пропорции столбцов нужно изменить на 20% и 80% для левого и правого столбца соответственно.

  В GUI это можно реализовать так:
    1. вначале сетка задается при 100% масштабе,
    1. затем можно переключиться на другой масштаб (200%, 50%),
    1. посмотреть что произошло,
    1. и передвинуть границы резиновых столбцов/строк.

- Внутри слоя (в текущем кадре) может быть несколько объектов, перекрывающих (z) друг друга.  
  Однако нет ни одной стандартной панели/палитры - "диспетчер объектов", в котором можно было бы увидеть все объекты в слое и их z.

- Точно изменить позицию _transform-point_ можно только через JSFL (написав скрипт).

- Для ускорения точного перемещения точек (узлов) кривой пришлось написать JSFL + диалоговое окно к нему.

- [происходит не всегда] Когда перемещаешь точки кривой при помощи `fl.getDocumentDOM().moveSelectedBezierPointsBy()`, а затем отменяешь действие <kbd>Ctrl+Z</kbd>,  
  то сами точки (узлы) возвращаются на свои прежние места, но управляющие точки остаются сдвинутыми (_форма кривой может изменится_).

- Для сохранения попиксельной точности отображения объектов в редакторе (чтобы они небыли размытыми) -  пришлось их сдвинуть на `-0.80` по каждой координате.

  Но в таком виде, при экспорте в GIF, все станет размытым. Поэтому все создается в символе `_main_`, который вставлен в монтажный стол `main` со сдвигом `+0.80` по каждой координате.

  **Примечание**:  
    При экспорте нужно экспортировать монтажный стол, и включить опцию "обрезать по рабочей области".

- Скругленные углы... точность их отрисовки - они постоянно хотят сдвинуться +/- относительно прямоугольника.

- Позиционирование и хинтинг текста:
  - без хинтинга слишком размыт/деформирован,
  - с хинтингом - деформирован меньше, но невозможно, например, позиционировать по центру.

- По прежнему нельзя создавать параметризованные группы графических объектов (классы/шаблоны).

  **Примеры параметров**: длина линии, длительность анимации, угол поворота, текст в текстовом поле... т.е. любой параметр, который можно изменить.

- Что можно сделать со встроенным экспортером в _анимированный GIF_? Не использовать его!  
  Он съест весь RAM и swap в несколько этапов (при предпросмотре):
    1. рендр всех кадров (в оригинальном качестве) в память
       > Зачем? Кадр и так рендрится быстро.  
       > Можно каждый кадр перерендрить по требованию - без использования "кеша",
       > а если размер кадра большой то рендр "на месте" будет быстрее, чем чтение отрендренного кадра из памяти.

    1. создание в памяти "сжатых" (для GIF) кадров
       > Зачем? Достаточно рассчитать глобальную палитру цветов,
       > и приводить к ней при отображении кадра в реальном времени.
       > Судя по нагрузке на CPU при проигрывании анимации - именно это и происходит,
       > так зачем съедать лишнюю память?

  К тому же пиксели у него получаются слишком "тяжелыми":
    - В теории
      ```
      4 byte (32 bit/pix) x 676 pix (W) x 1002 pix (H) x 200 frames = 517 MiB
      1 byte ( 8 bit/pix) x 676 pix (W) x 1002 pix (H) x 200 frames = 129 MiB
      ```
    - На практике (Private Virtual mem)
      ```
      перед запуском 157 MiB,
      после первого этапа 1627 MiB (delta: 1470 MiB > 517 MiB),
      после второго этапа 2240 MiB (delta:  613 MiB > 129 MiB)
      ```

  **Решение**:  
    Экспортировать все кадры в последовательность PNG (24 bit) файлов, и сделать из них GIF, используя другую программу (с _более лучшим_ кодом внутри).


### Оптимальный инструмент для анимирования подобной графики получился бы из... Corel R.A.V.E.
> Помните Corel R.A.V.E? Был такой аналог Macromedia Flash.  
> Было выпущено **3** версии, точнее **3 alpha** версии - ни одна из них не была доделана.

Почему именно Corel (CorelDRAW) а не Illustrator?

В CorelDRAW есть удобная (_для тех кто к ней привык_) и точная система динамических направляющих. Настолько удобная, что всю "инженерную графику"/"начертательную геометрию" (первый курс) я делал именно в CorelDRAW ( в виртуальном холсте, а не на реальном - бумаге ;) . И для всех последующих диаграмм, блок-схем, ..., вместо Visio (или любого другого подобного софта) я использовал CorelDRAW.

При этом очень помогала функция Pick Tool - копирование объекта при перетаскивании после нажатия правой кнопки мыши. Достаточно было предварительно нарисовать все основные блоки (блок включал в себя сгруппированную геометрию с пустыми текстовыми полями), а затем использовать их как шаблоны.

Все это вместе дало возможность логически подходить к расположению блоков на холсте ➔ делать схему более понятной/наглядной по сравнению с автоматическим распределением блоков в специализированном софте.

Для pixel-perfect в CorelDRAW есть возможность привязки вершины к одной из 9 точек пикселя (4 угла + середины 4-х сторон + центр). А также после экспорта в растр получается изображение, идентичное отображаемому на экране (при редактировании вектора).  
В Illustrator есть автоматический хинтинг (как и все автоматическое - не всегда получаешь нужный результат), а при экспорте в растр - несколько режимов сглаживания (отсутствует/геометрия/текст),
при этом ни в одном из режимов не получается изображение, идентичное выводимому на экран (при редактировании вектора; возможно это вызвано сочетанием видеокарты + драйверов + настройками системы).

Также удобно то, что любую манипуляцию с геометрией можно производить при помощи всего лишь 3-х инструментов:
  - pick - выбор и трансформация объектов,
  - shape - манипулирование вершинами кривых,
  - freehand - line - добавление новой геометрии, либо дорисовка существующей геометрии

➔ меньшее количество переключений между инструментами.  
Для сравнения: в Illustrator функции pick разбиты на 3 инструмента, shape - на 4, а freehand - на 3 инструмента.

**Следствие**:  
Illustrator больше подходит:
  - для создания "бесформенной геометрии" (геометрии произвольной формы, в которой точность не важна),
  - для создания векторного аналога растровой картины,

т.е. он больше подойдет для художников.  
CorelDRAW больше подойдет для создания "точной геометрии" (CAD; чертежи, диаграммы, схемы, инфо-графика, ...).  
Это все касается CorelDRAW версии <= X6, и Illustrator <= CS6.

**В итоге**:  
Оптимальный инструмент для анимации подобной графики получился бы из сочетания CorelDRAW + тайм-линии из After Effects + дополнений, перечисленных выше и в [заметке "За пределами групп"](https://plus.google.com/+ZiroKyl/posts/jmDydNZfKGG) (G+).

**P.S.** забавно, что на данный момент After Effects лучше подходит для анимации, чем Animate, а Animate/Flash мне раньше нравился за возможность создания красивых эффектов.


Workspace
---------
> Где-то здесь находится "точка невозврата", и если вы дочитали до этого места,
> то поздравляю с ее преодолением.

При работе над проектами я расположил палитры (панели) следующим образом:

![Adobe Animate Workspace](workspace.png)

Чего я пытался достичь при расположении палитр:

- распределить основное пространство экрана между холстом и тайм-линией:
  - высота холста в проекте больше ширены, поэтому холст получил максимальное вертикальное пространство
  - в основной сцене (символе `_main_`) используется большое количество слоев,
    желательно, чтобы все они могли поместиться на экран в тайм-линии,
    поэтому для тайм-линии важно как горизонтальное пространство, так и вертикальное
- вывести все элементы управления параметрами объекта на экран:
  - чтобы при выборе объекта на холсте сразу же видеть все его параметры
  - чтобы можно было изменить любой параметр объекта, не более чем за 1-2 клика
- видеть контекст (историю последних действий) на экране

### Как воссоздать такое расположение палитр?
На скриншоте над тайм-линией (1 столбец) расположены группы палитр в 3-х столбцах!  
Используемый в Animate/Flash тайловый GUI не позволит сделать это (разбить ячейку столбца на подстолбцы),
поэтому придется выйти за его пределы (:

1. очистить экран от палитр (должна остаться только закрепленная панель инструментов, и холст)
1. открыть тайм-линию, и разместить ее справа от холста
1. [основной шаг] над тайм-линией расположить палитру, которую вы не будите использовать,
   также желательно, чтобы ее содержимое не зависело от выбранного объекта
   (чтобы Animate/Flash впустую не обновлял и не перерисовывал элементы этой палитры),  
   я выбрал палитру "Layer Depth" (новые "Z-слои"; все равно их нельзя использовать внутри символа)
1. собирать остальные палитры
   1. собрать каждый из 3-х столбцов в отдельном _плавающем окне_
   1. по очереди прикрепить одно _окно_ к другому (подтянуть одно _окно_ к правому/левому краю другого _окна_)
   1. выровнять высоту всех столбцов, чтобы у _окна_ появилась общая нижняя граница
   1. перенести _окно_ на свое место (в правый верхний угол), при этом оно должно "примагнититься" к краю экрана, и остаться _окном_
1. подогнать размеры тайм-линии так, чтобы границы совпали с границами _плавающего окна_
1. сохранить Workspace.


Процесс создания анимации
-------------------------
На примере [Binarization](binarization/).

Вначале отрисовывается (в CorelDRAW) каждый _этап_ каждой _итерации_.  
_Итерации_ располагаются на отдельных страницах, а _этапы_ - на отдельных слоях внутри одной страницы.  
Так как внутри _этапа_ (при анимации) объекты будут менять свои позиции, то при отрисовке важно объединить на одном изображении ключевые позиции всех объектов со всех кадров _этапа_, и при этом стараться сохранить каждый объект в единственном экземпляре. Если объект имеет несколько видов (меняет свой вид в процессе анимации), то их можно отрисовать рядом.

Для каждой _итерации_ создается отдельный Flash (ActionScript) проект.  
_Этапы_ экспортируются из CorelDRAW в ".ai" (пробовал несколько вариантов экспорта-импорта, через разные форматы - этот вариант наиболее точный).  
В Animate/Flash:
  1. ".ai" импортируется в _монтажный стол_ "test"  
     (при импорте нужно игнорировать предупреждения - не применять авто-исправления)
  1. каждый _этап_ помещается в отдельный символ в папке `_test` библиотеки
  1. [настраиваются смещения](binarization/offset for Animate.md#При-экспорте-в-gif-с-включенным-обрезать-по-рабочей-области) (offset)
     > в разделе "[Это будет не просто...](#Это-будет-не-просто)" это было описано  
     > "для сохранения попиксельной точности отображения объектов в редакторе..."

  1. осталось немного подправить геометрию (у стрелок),
     и много повозится с [выравниванием текстовых блоков](binarization/offset for Animate.md#Текст).


### В реальности это было так...
Представьте весь процесс создания анимации в виде графа (дерево).  
Уровнями (_глубина_) в данном случае будут являться:
  1. отрисовка в CorelDRAW
  1. анимация в Animate/Flash
  1. экспорт в GIF

А ярусами (_ширина_; вершины на одном уровне) - итерации, этапы.

Вначале я прошелся по графу "прыжками" _в глубину_ до достижения первой _терминальной вершины_ (мозговой штурм):
  - придумывал представление объектов и общую концепцию
  - отрисовывал их ([LLTR-a2-binarization.cdr](binarization/LLTR-a2-binarization.cdr) - страница "[0]", слои "Слой 1" и "Слой All" )
  - искал инструмент (софт) для анимации
  - экспериментировал с вариантами экспорта-импорта
  - вспоминал "принципы анимации в Flash Prof" (давно уже им не пользовался, поэтому и выбрал его - чтобы вспомнить)
  - экспортировал в GIF и подбирал offset

Затем комбинированный проход в _глубину-ширину_ (опять же до достижения первой группы _терминальных вершин_):
  1. отрисовка всей нулевой итерации;
  1. анимация всей нулевой итерации;
  1. попытка экспорта в GIF всей нулевой итерации.

И окончательный проход в _ширину_:
  1. отрисовка оставшихся итераций;
  1. анимация оставшихся итераций;

Отдельно я анимировал "прыжки между итерациями": "[3...9](binarization/3...9)" и "[9...131](binarization/9...131)". Затем отрисовал и анимировал "[(start) -1](binarization/%28start%29%20-1)".  
И в конце - [экспорт в GIF](binarization/export to GIF.txt).

При этом каждый проход дает новую информацию для следующего прохода - позволяет оптимизировать работу при
следующем проходе. Например, распределение объектов (в основном текстовые блоки с числами) отличается в нулевой итерации от распределения в остальных итерациях. В нулевой итерации распределение визуально-равномерное, а в последующих итерациях распределение оптимизировано для более быстрого процесса анимации (объекты имеют равные промежутки в координатах).  
Эта оптимизация никак не сказывается на восприятие итогового GIF, т.к.:
  - разница составляет всего лишь 1 пиксель,
  - такую незначительную _визуальную неравномерность_ можно заметить только при первом просмотре (в нулевой итерации - мозг знакомится с тем, как объекты визуализируются - первое впечатление: все выровнено),  
  а когда все начнет повторяться (последующие итерации), внимание будет сосредоточено уже на другом.

Положительный побочный эффект от этого - мне не пришлось ничего _переделывать_ (каждое внесение _изменения_ в Animate/Flash - боль). Если бы я сразу же начал "ходить в _ширину_", то было бы много _изменений_ при переходах на следующий уровень.

**P.S.** Если вы, прочитав это подумали, что в процессе работы я постоянно думаю о графах,
         например: "о, сейчас надо пройти _в глубину_", то это не так. Это происходит интуитивно (автоматически),
         просто, если описать процесс в виде проходов по графу, то он будет выглядеть так.


How-to
------
В тексте выше были раскиданы ссылки на разные How-to/TODO списки из этого репозитория. Соберу их все вместе здесь:
- [offset for Animate](binarization/offset for Animate.md)
- [различия между итерациями](binarization/различия между итерациями.md)
- [export to GIF](binarization/export to GIF.txt)
- [Colors for palette](binarization/Colors for palette.md)

А для этого фрагмента я не нашел места в отдельном файле, оставлю его здесь:
> Перед сохранением [LLTR-a2-binarization.cdr](binarization/LLTR-a2-binarization.cdr) в репозиторий -
> открыть его в 7-Zip, и удалить директорию `color/profiles/cmyk` (она много весит).
>
> Если сохранять файл без встраивания цветовых профилей,
> то настройки профилей, при повторном открытии файла, будут сброшены на настройки по умолчанию.  
> Именно по этой причине оставляем директорию `color/profiles/rgb` на месте -
> если ее стереть, то после первого открытия будет все нормально,
> но при сохранении файла и повторном его открытии - _привет настройки по умолчанию_.

**P.S.** хорошо, что у Git дедупликации данных ~~в крови~~
         [в](https://habr.com/company/badoo/blog/163853)
         [архитектуре](https://stackoverflow.com/questions/25661952/does-git-de-duplicate-between-files),
         благодаря этому повторяющиеся (в разных итерациях) символы библиотеки не занимают лишнего места
         (но за этим нужно [следить](https://forums.adobe.com/message/6524026#6524026)).


Ссылки
------
Ссылки, которые я для чего-то сохранил:
  - [Flash Graphic Symbol](https://code.tutsplus.com/articles/flashs-underrated-graphic-symbol--active-9964)
  - [Управление изменениями формы с помощью контрольных точек (хинтов)](https://help.adobe.com/flash/9.0_ru/UsingFlash/help.html?content=WSd60f23110762d6b883b18f10cb1fe1af6-7d78.html)
  - [After Effects animation examples](https://github.com/airbnb/lottie-android#view-documentation-faq-help-examples-and-more-at-airbnbiolottie)
  - [Haiku](https://www.haiku.ai/blog/introducing-haiku/)
  - JSFL - Flash JavaScript File
    - [Flash JavaScript File (JSFL) - что это?](http://as3coder.blogspot.ru/2009/10/flash-javascript-file-jsfl.html)
    - [JSFL help](https://help.adobe.com/en_US/flash/cs/extend/WSd6d4f896b3a8801b2d17133e13cb5566c5d-8000.html)
    - [JSFL selection](https://habr.com/post/137101)
    - [JSFL swfPanel](https://help.adobe.com/en_US/flash/cs/extend/WS97eaa2ee0671cfc773a319f613cb6b7f50b-8000.html)
